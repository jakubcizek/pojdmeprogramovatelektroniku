<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bo쬰nka Offline</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://storage.googleapis.com/tfweb/api-test/dist/tf-tflite.js"></script>
    <style>
        .result-container {
            display: flex;
            align-items: center;
            margin-top: 20px;
        }
        .result-image {
            height: 200px;
            margin-right: 20px;
        }
    </style>
    <script>
        let tfliteModel = null;
        let maxCPUCount = navigator.hardwareConcurrency / 2; // Pro neuronku se alokuje max polovina logickych jader tveho CPU

        // Funkci캜ka pro nahr치n칤 Bo쬰nky ze souboru
        async function loadModel(file) {
            console.log("Jadra: " + navigator.hardwareConcurrency);
            const arrayBuffer = await file.arrayBuffer();
            tfliteModel = await tflite.loadTFLiteModel(arrayBuffer, {
                    numThreads: maxCPUCount,
                    enableProfiling: true,
                }
            );
            if(!tfliteModel){
                console.log("To model nen칤 nahran칳");
                document.getElementById("status").innerHTML = `<span style="color:red">Bo쬰nka je smutn치, proto쬰 je n캩co 코patn캩. Koukni do logu 游봋</span>`;
            }
            else{
                console.log("To model je nahran칳");
                document.getElementById("status").innerHTML = `<span style="color:green">Bo쬰na je v po콏치dku nahran치. K dispozici bude m칤t <b>a ${maxCPUCount} logick칳ch jader</b>, tedy 1/${navigator.hardwareConcurrency/maxCPUCount} tv칠ho legra캜n칤ho procesoru 游녨</span>`;
            }
        }

        // Funkci캜ka pro zpracov치n칤 obr치zku v Bo쬰nce
        async function handleImage(inputElement) {
            if (!tfliteModel) {
                alert("To jsi blb칳 u, 캜i co?\nDy콘 p칤코u, 쬰 mus칤코 nejprve nahr치t model Bo쬰nky...\nTo je materi치l tady zase.");
                return;
            }

            const file = inputElement.files[0];
            const image = await readImage(file);

             // P콏iprav칤me vstup do modelu, kter칳 o캜ek치v치 obr치zky v rozli코en칤 416x416px
             // Zbytek ne콏e코
             const inputTensor = tf.image
            .resizeBilinear(tf.browser.fromPixels(image), [416, 416])
            .expandDims()
            .div(127.5)
            .sub(1);

            // Te캞 data po코leme do Kalkaty,
            // kde 512 zaplacen칳ch brig치dn칤k콢 odhadne,
            // jak칠 je na obr치zku po캜as칤
            let startTime = performance.now();
            const outputTensor = tfliteModel.predict(inputTensor);
            const duration = performance.now() - startTime;
            // Zobraz칤me v칳sledky
            // results obsahuje pole se t콏emi pravd캩podobnostmi odpov칤daj칤c칤 po콏ad칤 jasno, polojasno, zata쬰no
            const results = Array.from(outputTensor.dataSync()); 
            displayResults(results, duration, image);
        }

        // Funkci캜ka pro zobrazen칤 v칳sledku
        function displayResults(results, duration, image) {
            const resultsElement = document.getElementById("results");
            const resultContainer = document.createElement("div");
            resultContainer.className = "result-container";

            // Vytvo콏칤me procentu치ln칤 v칳sledky a se콏ad칤me od nejv캩t코칤ho
            const resultsArray = [
                { name: "Jasno", value: (results[0] * 100.0).toFixed(2) },
                { name: "Polojasno", value: (results[1] * 100.0).toFixed(2) },
                { name: "Zata쬰no", value: (results[2] * 100.0).toFixed(2) }
            ];
            resultsArray.sort((a, b) => b.value - a.value);
            let resultsHTML = resultsArray.map((result, index) => 
                index === 0 ? `<strong>${result.name}: ${result.value} %</strong>` : `${result.name}: ${result.value} %`
            ).join("<br>") + `<br><br><i>Bo쬰nka na tv칠m sm캩코n칠m hardwaru p콏em칳코lela ${duration.toFixed(2)} ms</i>`;

            resultContainer.innerHTML = `
                <div><img src="${image.src}" class="result-image"></div>
                <div><h2>Bo쬰nka si mysl칤, 쬰 vid칤 toto:</h2>${resultsHTML}</div>
            `;
            resultsElement.appendChild(resultContainer);
        }

        // Funkci캜ka pro nahr치n칤 obr치zku
        async function readImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.src = event.target.result;
                };
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        }
    </script>
</head>
<body>
    <h1>Bo쬰nka Offline: Lok치ln칤 detektor po캜as칤 na fotografii</h1>
    <p>
        Toto je narychlo zbastlen치 demonstrace neuronky Bo쬰nka pro detekci po캜as칤 na fotografii, kter치 d칤ky Tensorflow.js pob캩쮂 p콏칤mo na va코em CPU. <b>Bo쬰nku mus칤te nejprve do aplikace nahr치t</b>. Nena캜칤t치 se kdesi z cloudu. D칤ky tomu by m캩lo v코e fungovat v Chromu i lok치ln캩. Prost캩 sta캜칤 na캜칤st m칤stn칤 soubor bozenka.html. Dv캩 zjendodu코en칠 verze Bo쬰nky m콢쬰te st치hnout z GitHubu: <b><a href="https://github.com/jakubcizek/pojdmeprogramovatelektroniku/raw/master/bozenka/bozenka_f16.tflite">bozenka_f16.tflite</a> (2,8 MB)</b>, <b><a href="https://github.com/jakubcizek/pojdmeprogramovatelektroniku/raw/master/bozenka/bozenka_f32.tflite">bozenka_f32.tflite</a> (5,6 MB)</b>.
    </p>
    <p>
        Toto je pom캩rn캩 hloup치 verze Bo쬰nky. Je to pouze proof-of-concept b캩hu v Tensorflow.js. Mnohem schopn캩j코칤 verze Bo쬰nky u캜en치 na stovk치ch tis칤c fotografi칤 oblohy si teprve od lo켿sk칠ho podzimu pr콢b캩쬹캩 stahuje sn칤mky z webkamer ;-)
    </p>
    <p>
        Ale pozor, neb캩쮂 to cel칠 offline, z cloudu se toti mus칤 st치hnout samotn칳 runtime Tensorflow.js. D캩l치 to p치r megabajt콢!    
    </p>
    <input type="file" id="upload-model" accept=".tflite" style="display: none;" onchange="loadModel(this.files[0])">
    <input type="file" id="upload-image" accept="image/jpeg,image/png" style="display: none;" onchange="handleImage(this)">
    <h3>1) Nahraj z PC sta쬰n칳 model Bo쬰nky</h3>
    <button onclick="document.getElementById('upload-model').click()">Nahraj Bo쬰nku</button>&nbsp;<span id="status"></span>
    <h3>2) Jakmile je model nahran칳, m콢쬰코 do Bo쬰nky l치dovat obr치zky</h3>
    <button onclick="document.getElementById('upload-image').click()">Nahraj JPEG obr치zek</button>
    <div id="results"></div>
    <p>
        <b>Testov치no na x86-64, Windows 11 a v prohl칤쬰캜칤ch Chrome a Firefox</b><br>
    </p>
</body>
</html>
